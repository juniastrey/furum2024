{
  "name": "Custom: Scrolling Text",
  "id": "CmLQLitung2oMeBBm",
  "sources": {
    "main": "// Note: Modified for 4px font. Comments from original for 8px font are unchanged.\n\n/*\n  Scrolling text marquee 2D\n  \n  This pattern animates ASCII characters scrolling across an LED matrix.\n  \n    Demo: https://youtu.be/668eQjiqSRQ\n  \n  The default settings work well with the $14 8x8 matrix sold here:\n  \n    https://www.tindie.com/products/electromage/electromage-8x8-led-matrix/\n  \n  Use the mapper to define how the matrix is wired (for example, zig-zag). \n  The 8x8 grid above works with the default \"Matrix\" example on the Mapper tab.\n  \n  With no map and just a 1D strip, you can use this to light paint text:\n  \n    https://photos.app.goo.gl/vU2BQsP6V84Zr6Df7\n  \n  Author: Jeff Vyduna (https://ngnr.org)\n  Bugfixes: Zeb (https://forum.electromage.com/u/zeb)\n*/\n\n// Characters we want to scroll by every second. Try 3 for a matrix, or 30 for\n// persistence-of-vision on a strip.\nvar speed = 3\n\n// Define the message to be scrolled across the display\nvar messageLength = 12\nexport var message = array(messageLength) // Exported for setting via webSockets\n\n// \"  Hello?!?\"\nmessage[0] = 32; message[1] = 32;  // Leading spaces\nmessage[2] = 72;   // H\nmessage[3] = 101;  // e\nmessage[4] = 108;  // l \nmessage[5] = 108;  // l \nmessage[6] = 111;  // o \nmessage[7] = 63; message[8] = 33; message[9] = 63 // \"?!?\"\n\n/* \n  ASCII Chart\n\n  32      48 0    65 A   74 J    83 S    97  a    106 j    115 s\n  33 !    49 1    66 B   75 K    84 T    98  b    107 k    116 t\n  34 \"    50 2    67 C   76 L    85 U    99  c    108 l    117 u\n  35 #    51 3    68 D   77 M    86 V    100 d    109 m    118 v\n  36 $    52 4    69 E   78 N    87 W    101 e    110 n    119 w\n  37 %    53 5    70 F   79 O    88 X    102 f    111 o    120 x\n  38 &    54 6    71 G   80 P    89 Y    103 g    112 p    121 y\n  39 '    55 7    72 H   81 Q    90 Z    104 h    113 q    122 z\n  40 (    56 8    73 I   82 R            105 i    114 r    \n  41 )    57 9                                   \n  42 *    58 :                   91 [                      123 {\n  43 +    59 ;                   92 \\                      124 |\n  44 ,    60 <                   93 ]                      125 }\n  45 -    61 =                   94 ^                      126 ~\n  46 .    62 >                   95 _    \n  47 /    63 ?                   96 `                \n          64 @                                            \n*/\n\n\n// Define the font's character set bitmap. See \"Font Implementation\" below.\nvar charRows = 4 // Rows in a character. 1 array per row.\nvar charCols = 4 // Columns in a character. 1 bit per column.\n\nvar fontCharCount = 128 // Max characters in the font. Must be a multiple of 8.\nvar fontBitmap = array(charRows)\nfor (row = 0; row < charRows; row++) fontBitmap[row] = array(fontCharCount / 8)\n\n// Global 8x8bit array for storing and fetching characters from fontBitmap\nvar character = array(charRows)\n\n// Define the 2D matrix display. If your matrix is different dimentions, change\n// these to match or use a smaller matrixRows to scale your text height to fill.\nvar matrixRows = 4\nvar matrixCols = 30\nvar renderBuffer = array(matrixRows)\nfor (row = 0; row < matrixRows; row++) renderBuffer[row] = array(matrixCols)\n\nvar timer = 0 // Accumulates the ms between each beforeRender()\n\n// Calculate the ms between each left shift of the message across matrix columns\nvar colShiftPeriod = 1000 / speed / charCols\n\nexport function beforeRender(delta) {\n  timer += delta\n  if (timer > colShiftPeriod) { \n    timer -= colShiftPeriod\n    loadNextCol() // Shift and load a new column every colShiftPeriod ms\n  }\n}\n\nexport var hue, sat     // Exported so you can set them over websockets\nhue = 0.05; sat = 0.9   // warm white\nexport var rainbow = true\n\nexport function render2D(index, x, y) {\n  // y is in world units of 0...1 where (0,0) is the top-left and y is +↓\n  row = floor(y * matrixRows)\n\n  // The column to render is like the row, but physical column 0 (the leftmost)\n  // starts bufferPointer columns into the renderBuffer.\n  col = (floor(x * matrixCols) + bufferPointer) % matrixCols\n  \n  v = renderBuffer[row][col]  // 1 or 0\n  if (rainbow)\n    hsv(col / matrixCols, sat, v)\n  else\n    hsv(hue, sat, v)\n}\n\n// On a strip, render the leftmost column. You can use this to light paint in\n// long exposure photographs, or render text in POV projects\nexport function render(index) {\n  // Flip such that pixel 0, usually the closest to power, is the bottom of text\n  index = pixelCount - index - 1\n  \n  // Mode 1: Use entire strip as a full character line height.\n  // row = floor(charRows * index/ pixelCount)\n  \n  // Mode 2: repeat the characters vertically, with linespacing\n  // If you flicker your eyes left-right, you can see the characters.\n  // Looks best if you set `speed` above to much faster, like 30 chars/sec\n  row = index % floor(1.5 * charRows) // 0.5em lineSpacing\n  if (row > charRows - 1) { hsv(0, 0, 0); return } // blank rows\n\n  // Render column 0, which starts bufferPointer columns into the renderBuffer\n  col = bufferPointer % matrixCols\n  \n  // The color is added for light painting rainbows, and so that it's still\n  // somewhat interesting on strips / the default sequencer\n  hue = wave(time(0.02)) - index / pixelCount\n  \n  hsv(hue, sat, renderBuffer[row][col])\n}\n\n\n// When we render the renderBuffer, we start by loading the leftmost column of\n// the matrix from the `bufferPointer` column in the renderBuffer.\nvar bufferPointer = 0 \n\n/*\n  E.g.: 8x8 matrix, rendering halfway through \"AC\": Right side of A, left of C\n\n          renderbuffer[r][c]             Renders as:\n\n  `bufferPointer` == 4 means leftmost column is here, and wraps around to 3\n                     ↓       \n       col = 0 1 2 3 4 5 6 7                0 1 2 3 4 5 6 7\n    row = 0  . . . 1 1 . . .             0  1 . . . . . . 1  \n          1  . . 1 1 1 1 . .             1  1 1 . . . . 1 1  \n          2  . 1 1 . . 1 1 .             2  . 1 1 . . 1 1 .  \n          3  . 1 1 . . 1 1 .             3  . 1 1 . . 1 1 .  \n          4  . 1 1 . 1 1 1 .             4  1 1 1 . . 1 1 .  \n          4  . . 1 1 . 1 1 .             4  . 1 1 . . . 1 1  \n          5  . . . 1 . 1 1 .             5  . 1 1 . . . . 1  \n          7  . . . . . . . .             7  . . . . . . . .  \n                     ↑\n                     This column will be replaced with the next column of \"C\",\n                       ↑ then we'll advance `bufferPointer`\n                     \nEach element is a 16.16 fixed point number, so you could decide to pack HSV or \nRGB info into each byte, but this example is monochrome so each element just \nstores a 0 or 1, making rendering as simple as:\n\n    if (renderBuffer[row][col]) hsv(0,0,1)\n*/\n\nvar messageCols = messageLength * charCols // e.g., 12 chars have 96 columns\nvar messageColPointer = 0 // The next column of the overall message to load\n\n// Load the next column from `message` into `renderBuffer` at `bufferPointer`\nfunction loadNextCol() {\n  charIndex = message[floor(messageColPointer / charCols)]\n  fetchCharacter(charIndex) // loads global `character` with ASCII charIndex\n  \n  colIndex = messageColPointer % charCols\n  for (row = 0; row < charRows; row++) {\n    bit = (((character[row] << colIndex) & 0b1000) == 0b1000)\n    renderBuffer[row][bufferPointer] = bit\n  }\n  \n  bufferPointer = (bufferPointer + 1) % matrixCols\n  messageColPointer = (messageColPointer + 1) % messageCols\n}\n\n\n\n/*\n  Font Implementation\n  \n  Pixelblaze currently supports up to 64 arrays with 2048 array elements.\n  \n  To store a character set of 8x8 bit characters, we use 8 arrays, \n  one for each row.\n  \n  Four 8-bit maps are packed into each 32 bit array element. This makes the\n  bitwise code a little hard to follow, but uses memory efficiently. The 8 most\n  significant bits are referred to as \"bank 0\"; the next eight bits just left of\n  the binary point are \"bank 1\", etc.\n  \n  Here's the scheme used to store the font bitmap. A period is a zero.\n  \n    ASCII character  A        B        C        D        E\n        `charIndex`  65       66       67       68       69\n      array element  [16]     [16]     [16]     [16]     [17]\n               bank  0        1        2        3        0      \n      fontBitmap[0]  ..11.... 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[1]  .1111... .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[2]  11..11.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[3]  11..11.. .11111.. 11...... .11..11. .1111...\n      fontBitmap[4]  111111.. .11..11. 11...... .11..11. .11.1...\n      fontBitmap[5]  11..11.. .11..11. .11..11. .11.11.. .11...1.\n      fontBitmap[6]  11..11.. 111111.. ..1111.. 11111... 1111111.\n      fontBitmap[7]  ........ ........ ........ ........ ........\n  \n  charIndex 0..31 (traditionally the ASCII control characters) are left \n  blank for user-defined custom characters.\n*/\n\n/*\n  Font and character functions\n\n  The storeCharacter functions take the character index (< `fontCharCount`) and \n  8 rows of 8 bits. Each row is a byte representing 8 bits of on/off bitmap data\n  to become the pixels of a character. Therefore, this implementation is \n  currently tightly coupled to 8-bit wide characters.\n*/\n\n/*\n  At character index `charIndex`, store 8 bytes of row data specified as \n  sequential arguments r0-r7. This allows us to easily use the public domain \n  font specified as comma-delimited hex bytes at:\n  \n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\nfunction storeCharacter(charIndex, r0, r1, r2, r3) {\n  element = floor(charIndex / 8)\n  bank = charIndex % 8\n  packByte(0, element, bank, r0)\n  packByte(1, element, bank, r1)\n  packByte(2, element, bank, r2)\n  packByte(3, element, bank, r3)\n}\n\n/*\n  This alternate style stores the character using the 8 row global array named \n  `character`. It could be useful for storing sprites after transformations to\n  create animations.\n*/\nfunction storeCharacter2(charIndex) {\n  element = floor(charIndex / 8)\n  bank = charIndex % 8\n  for (var row = 0; row < charRows; row++) {\n    packByte(row, element, bank, character[row])\n  }\n}\n\n// Loads the global `character` from the specified charIndex\nfunction fetchCharacter(charIndex) {\n  element = floor(charIndex / 8)\n  bank = charIndex % 8\n  for (var row = 0; row < charRows; row++) {\n    character[row] = unpackByte(row, element, bank)\n  }\n}\n\n/*\n  For a given row of a font's pixel data (fontBitmap[row]), there's a \n  (fontCharCount / 4) element long array that holds 32 bits per array element. \n  Thinking of each array element as a 4-byte word, the \"bank\" (0..3) specifies \n  which set of 8 bits we're storing for a particular character. Characters are \n  referred to by their charIndex (ASCII number), so:\n  bank 0 in elements 0, 1, & 2 store the data for characters 0, 4, 8, etc;\n  Bank 1 in elements 0, 1, & 2 store the data for characters 1, 5, 9, etc.\n  \n  The method below is used because the bitwise operators only work on \n  the top 16 bits.\n*/\nvar byteHolder = array(8)\nfunction packByte(row, element, bank, byte) {\n  original = fontBitmap[row][element]\n  \n  // Load a 4-element array with the individual bytes in this 32 bit 'word'\n  for (_bank = 0; _bank < 8; _bank++) {\n    byteHolder[_bank] = (((original << (_bank * 4)) & 0xF000) >> 12) & 0xF\n  }\n  \n  // Override the 8 bits we're trying to store\n  byteHolder[bank] = byte \n  \n  // Reassemble the 32 bit 'word'\n  fontBitmap[row][element] = (byteHolder[0] << 12) \n                           + (byteHolder[1] << 8)\n                           + (byteHolder[2] << 4) \n                           + byteHolder[3]\n                           + (byteHolder[4] >> 4)\n                           + (byteHolder[5] >> 8) \n                           + (byteHolder[6] >> 12)\n                           + (byteHolder[7] >> 16)\n}\n\n// Inverse of packByte()\nfunction unpackByte(row, element, bank) {\n  word = fontBitmap[row][element]\n  if (bank > 3) {\n    byte = word << (4 * (bank - 3))\n  } else if (bank < 3) {\n    byte = word >> (4 * (3 - bank))\n  } else {\n    byte = word\n  }\n  return byte & 0xF // Zero out all but the 8 bits left of the binary point\n}\n\n\n\n/* \n  Font Data\n\n  Public domain, courtesy of\n  https://github.com/rene-d/fontino/blob/master/font8x8_ib8x8u.ino\n*/\n\nstoreCharacter( 32, 0b0000, 0b0000, 0b0000, 0b0000)  // 0x20 (space)\nstoreCharacter( 33, 0b1000, 0b1000, 0b0000, 0b1000)  // 0x21 (exclam)\nstoreCharacter( 34, 0b1010, 0b1010, 0b0000, 0b0000)  // 0x22 (quotedbl)\nstoreCharacter( 35, 0b0010, 0b1110, 0b1110, 0b1000)  // 0x23 (numbersign)\nstoreCharacter( 36, 0b0110, 0b1100, 0b0110, 0b1100)  // 0x24 (dollar)\nstoreCharacter( 37, 0b1010, 0b0110, 0b1100, 0b1010)  // 0x25 (percent)\nstoreCharacter( 38, 0b0110, 0b1100, 0b1010, 0b1110)  // 0x26 (ampersand)\nstoreCharacter( 39, 0b1000, 0b1000, 0b0000, 0b0000)  // 0x27 (quotesingle)\nstoreCharacter( 40, 0b0100, 0b1000, 0b1000, 0b0100)  // 0x28 (parenleft)\nstoreCharacter( 41, 0b1000, 0b0100, 0b0100, 0b1000)  // 0x29 (parenright)\nstoreCharacter( 42, 0b1110, 0b0100, 0b1010, 0b0000)  // 0x2a (asterisk)\nstoreCharacter( 43, 0b0100, 0b1110, 0b0100, 0b0000)  // 0x2b (plus)\nstoreCharacter( 44, 0b0000, 0b0000, 0b0100, 0b1000)  // 0x2c (comma)\nstoreCharacter( 45, 0b0000, 0b1100, 0b0000, 0b0000)  // 0x2d (hyphen)\nstoreCharacter( 46, 0b0000, 0b0000, 0b0000, 0b1000)  // 0x2e (period)\nstoreCharacter( 47, 0b0010, 0b0100, 0b0100, 0b1000)  // 0x2f (slash)\nstoreCharacter( 48, 0b0100, 0b1110, 0b1010, 0b0100)  // 0x30 (zero)\nstoreCharacter( 49, 0b1100, 0b0100, 0b0100, 0b1110)  // 0x31 (one)\nstoreCharacter( 50, 0b1100, 0b0010, 0b0100, 0b1110)  // 0x32 (two)\nstoreCharacter( 51, 0b1100, 0b0110, 0b0010, 0b1100)  // 0x33 (three)\nstoreCharacter( 52, 0b1010, 0b1110, 0b0010, 0b0010)  // 0x34 (four)\nstoreCharacter( 53, 0b1110, 0b1100, 0b0010, 0b0100)  // 0x35 (five)\nstoreCharacter( 54, 0b0110, 0b1000, 0b1110, 0b1100)  // 0x36 (six)\nstoreCharacter( 55, 0b1110, 0b0010, 0b0100, 0b1000)  // 0x37 (seven)\nstoreCharacter( 56, 0b1110, 0b1110, 0b1010, 0b1110)  // 0x38 (eight)\nstoreCharacter( 57, 0b0110, 0b1110, 0b0010, 0b1100)  // 0x39 (nine)\nstoreCharacter( 58, 0b1000, 0b0000, 0b1000, 0b0000)  // 0x3a (colon)\nstoreCharacter( 59, 0b0100, 0b0000, 0b0100, 0b1000)  // 0x3b (semicolon)\nstoreCharacter( 60, 0b0100, 0b1000, 0b0100, 0b0000)  // 0x3c (less)\nstoreCharacter( 61, 0b1100, 0b0000, 0b1100, 0b0000)  // 0x3d (equal)\nstoreCharacter( 62, 0b1000, 0b0100, 0b1000, 0b0000)  // 0x3e (greater)\nstoreCharacter( 63, 0b1110, 0b0010, 0b0000, 0b0100)  // 0x3f (question)\nstoreCharacter( 64, 0b1110, 0b1110, 0b1110, 0b1110)  // 0x40 (at)\nstoreCharacter( 65, 0b0100, 0b1010, 0b1110, 0b1010)  // 0x41 (A)\nstoreCharacter( 66, 0b1110, 0b1100, 0b1010, 0b1100)  // 0x42 (B)\nstoreCharacter( 67, 0b0110, 0b1000, 0b1000, 0b0110)  // 0x43 (C)\nstoreCharacter( 68, 0b1100, 0b1010, 0b1010, 0b1100)  // 0x44 (D)\nstoreCharacter( 69, 0b1110, 0b1100, 0b1000, 0b1110)  // 0x45 (E)\nstoreCharacter( 70, 0b1110, 0b1100, 0b1000, 0b1000)  // 0x46 (F)\nstoreCharacter( 71, 0b0110, 0b1000, 0b1010, 0b0110)  // 0x47 (G)\nstoreCharacter( 72, 0b1010, 0b1110, 0b1010, 0b1010)  // 0x48 (H)\nstoreCharacter( 73, 0b1110, 0b0100, 0b0100, 0b1110)  // 0x49 (I)\nstoreCharacter( 74, 0b1110, 0b0010, 0b1010, 0b0100)  // 0x4a (J)\nstoreCharacter( 75, 0b1010, 0b1100, 0b1010, 0b1010)  // 0x4b (K)\nstoreCharacter( 76, 0b1000, 0b1000, 0b1000, 0b1110)  // 0x4c (L)\nstoreCharacter( 77, 0b1110, 0b1110, 0b1010, 0b1010)  // 0x4d (M)\nstoreCharacter( 78, 0b1100, 0b1010, 0b1010, 0b1010)  // 0x4e (N)\nstoreCharacter( 79, 0b0100, 0b1010, 0b1010, 0b0100)  // 0x4f (O)\nstoreCharacter( 80, 0b1110, 0b1010, 0b1110, 0b1000)  // 0x50 (P)\nstoreCharacter( 81, 0b0100, 0b1010, 0b1110, 0b0110)  // 0x51 (Q)\nstoreCharacter( 82, 0b1100, 0b1010, 0b1100, 0b1010)  // 0x52 (R)\nstoreCharacter( 83, 0b1110, 0b1100, 0b0010, 0b1110)  // 0x53 (S)\nstoreCharacter( 84, 0b1110, 0b0100, 0b0100, 0b0100)  // 0x54 (T)\nstoreCharacter( 85, 0b1010, 0b1010, 0b1010, 0b0100)  // 0x55 (U)\nstoreCharacter( 86, 0b1010, 0b1010, 0b1100, 0b1000)  // 0x56 (V)\nstoreCharacter( 87, 0b1010, 0b1010, 0b1110, 0b1110)  // 0x57 (W)\nstoreCharacter( 88, 0b1010, 0b0100, 0b1010, 0b1010)  // 0x58 (X)\nstoreCharacter( 89, 0b1010, 0b0100, 0b0100, 0b0100)  // 0x59 (Y)\nstoreCharacter( 90, 0b1110, 0b0100, 0b1000, 0b1110)  // 0x5a (Z)\nstoreCharacter( 91, 0b1100, 0b1000, 0b1000, 0b1100)  // 0x5b (bracketleft)\nstoreCharacter( 92, 0b1000, 0b0100, 0b0100, 0b0010)  // 0x5c (backslash)\nstoreCharacter( 93, 0b1100, 0b0100, 0b0100, 0b1100)  // 0x5d (bracketright)\nstoreCharacter( 94, 0b0100, 0b1010, 0b0000, 0b0000)  // 0x5e (asciicircum)\nstoreCharacter( 95, 0b0000, 0b0000, 0b0000, 0b1110)  // 0x5f (underscore)\nstoreCharacter( 96, 0b1000, 0b0100, 0b0000, 0b0000)  // 0x60 (grave)\nstoreCharacter( 97, 0b0000, 0b0110, 0b1010, 0b0110)  // 0x61 (a)\nstoreCharacter( 98, 0b1000, 0b1100, 0b1010, 0b1100)  // 0x62 (b)\nstoreCharacter( 99, 0b0000, 0b0110, 0b1000, 0b0110)  // 0x63 (c)\nstoreCharacter(100, 0b0010, 0b0110, 0b1010, 0b0110)  // 0x64 (d)\nstoreCharacter(101, 0b0000, 0b1110, 0b1100, 0b0110)  // * 0x65 (e)\nstoreCharacter(102, 0b0010, 0b0100, 0b1110, 0b0100)  // 0x66 (f)\nstoreCharacter(103, 0b0000, 0b1110, 0b0110, 0b1100)  // 0x67 (g)\nstoreCharacter(104, 0b1000, 0b1100, 0b1010, 0b1010)  // 0x68 (h)\nstoreCharacter(105, 0b1000, 0b0000, 0b1000, 0b1000)  // 0x69 (i)\nstoreCharacter(106, 0b1000, 0b0100, 0b0100, 0b1100)  // 0x6a (j)\nstoreCharacter(107, 0b1000, 0b1010, 0b1100, 0b1010)  // 0x6b (k)\nstoreCharacter(108, 0b1000, 0b1000, 0b1000, 0b0100)  // * 0x6c (l)\nstoreCharacter(109, 0b0000, 0b1110, 0b1110, 0b1010)  // 0x6d (m)\nstoreCharacter(110, 0b0000, 0b1100, 0b1010, 0b1010)  // 0x6e (n)\nstoreCharacter(111, 0b0000, 0b0100, 0b1010, 0b0100)  // * 0x6f (o)\nstoreCharacter(112, 0b0000, 0b1110, 0b1110, 0b1000)  // 0x70 (p)\nstoreCharacter(113, 0b0000, 0b1110, 0b1110, 0b0010)  // 0x71 (q)\nstoreCharacter(114, 0b0000, 0b1110, 0b1000, 0b1000)  // 0x72 (r)\nstoreCharacter(115, 0b0000, 0b0110, 0b0100, 0b1100)  // 0x73 (s)\nstoreCharacter(116, 0b0100, 0b1110, 0b0100, 0b0010)  // 0x74 (t)\nstoreCharacter(117, 0b0000, 0b1010, 0b1010, 0b0110)  // 0x75 (u)\nstoreCharacter(118, 0b0000, 0b1010, 0b1010, 0b0100)  // 0x76 (v)\nstoreCharacter(119, 0b0000, 0b1010, 0b1110, 0b1110)  // 0x77 (w)\nstoreCharacter(120, 0b0000, 0b1010, 0b0100, 0b1010)  // 0x78 (x)\nstoreCharacter(121, 0b0000, 0b1010, 0b0100, 0b0100)  // 0x79 (y)\nstoreCharacter(122, 0b0000, 0b1100, 0b0100, 0b0110)  // 0x7a (z)\nstoreCharacter(123, 0b0100, 0b0100, 0b1000, 0b0100)  // 0x7b (braceleft)\nstoreCharacter(124, 0b1000, 0b1000, 0b1000, 0b1000)  // 0x7c (bar)\nstoreCharacter(125, 0b1000, 0b1000, 0b0100, 0b1000)  // 0x7d (braceright)\nstoreCharacter(126, 0b0010, 0b1110, 0b1000, 0b0000)  // 0x7e (asciitilde)\n\n\n// Other user-defined custom characters\n\n// ASCII 63 is the question mark - here's an alternative from the \n// Sinclair ZX81 font, stored in custom slot 30\nstoreCharacter(30,\n  0b00000000,\n  0b00111100,\n  0b01000010,\n  0b00000100\n)\n\n// This demonstrates copying the character, altering it, then storing it in the \n// next slot. You could use this for programmatic animation.\nfetchCharacter(30)\ncharacter[3] = 0b00001000\nstoreCharacter2(31)\n"
  },
  "preview": "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"
}